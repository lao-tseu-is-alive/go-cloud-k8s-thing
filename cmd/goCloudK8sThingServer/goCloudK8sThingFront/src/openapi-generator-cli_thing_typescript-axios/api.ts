/* tslint:disable */
/* eslint-disable */
/**
 * Thing microservice written in Golang
 * OpenApi Specification for an API to manage Thing
 *
 * The version of the OpenAPI document: 0.0.5
 * Contact: go-cloud-k8s-thing@goeland.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface JsonWebToken
 */
export interface JsonWebToken {
    /**
     *
     * @type {string}
     * @memberof JsonWebToken
     */
    'token': string;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     *
     * @type {number}
     * @memberof ModelError
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 *
 * @export
 * @interface Thing
 */
export interface Thing {
    /**
     * cet Universally unique identifier (UUID) sera généré automatiquement pour vous
     * @type {string}
     * @memberof Thing
     */
    'id': string;
    /**
     * FK sur la clé primaire du TypeThing de cet objet
     * @type {number}
     * @memberof Thing
     */
    'type_id': number;
    /**
     *
     * @type {string}
     * @memberof Thing
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof Thing
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof Thing
     */
    'comment'?: string;
    /**
     *
     * @type {number}
     * @memberof Thing
     */
    'external_id'?: number;
    /**
     *
     * @type {string}
     * @memberof Thing
     */
    'external_ref'?: string;
    /**
     *
     * @type {string}
     * @memberof Thing
     */
    'build_at'?: string;
    /**
     *
     * @type {ThingStatus}
     * @memberof Thing
     */
    'status'?: ThingStatus;
    /**
     *
     * @type {string}
     * @memberof Thing
     */
    'contained_by'?: string;
    /**
     *
     * @type {number}
     * @memberof Thing
     */
    'contained_by_old'?: number;
    /**
     *
     * @type {boolean}
     * @memberof Thing
     */
    'inactivated': boolean;
    /**
     *
     * @type {string}
     * @memberof Thing
     */
    'inactivated_time'?: string;
    /**
     *
     * @type {number}
     * @memberof Thing
     */
    'inactivated_by'?: number;
    /**
     *
     * @type {string}
     * @memberof Thing
     */
    'inactivated_reason'?: string;
    /**
     *
     * @type {boolean}
     * @memberof Thing
     */
    'validated'?: boolean;
    /**
     *
     * @type {string}
     * @memberof Thing
     */
    'validated_time'?: string;
    /**
     *
     * @type {number}
     * @memberof Thing
     */
    'validated_by'?: number;
    /**
     *
     * @type {number}
     * @memberof Thing
     */
    'managed_by'?: number;
    /**
     * date de création de cet enregistrement dans la base
     * @type {string}
     * @memberof Thing
     */
    'created_at'?: string;
    /**
     * identifiant de l\'utilisateur ayant créé cet enregistrement
     * @type {number}
     * @memberof Thing
     */
    'created_by': number;
    /**
     * date de la dernière modification de cet enregistrement
     * @type {string}
     * @memberof Thing
     */
    'last_modified_at'?: string;
    /**
     * utilisateur ayant effectué la dernière modication de cet enregistrement
     * @type {number}
     * @memberof Thing
     */
    'last_modified_by'?: number;
    /**
     * cet enregisrement a été marqué comme effacé
     * @type {boolean}
     * @memberof Thing
     */
    'deleted': boolean;
    /**
     * date à laquelle cet enregisrement a été marqué comme effacé
     * @type {string}
     * @memberof Thing
     */
    'deleted_at'?: string;
    /**
     * utilisateur ayant demandé de marquer cet enregisrement comme effacé
     * @type {number}
     * @memberof Thing
     */
    'deleted_by'?: number;
    /**
     * permet de stocker des attributs complémentaires au format json
     * @type {object}
     * @memberof Thing
     */
    'more_data'?: object;
    /**
     *
     * @type {number}
     * @memberof Thing
     */
    'pos_x': number;
    /**
     *
     * @type {number}
     * @memberof Thing
     */
    'pos_y': number;
}


/**
 *
 * @export
 * @interface ThingList
 */
export interface ThingList {
    /**
     *
     * @type {string}
     * @memberof ThingList
     */
    'id': string;
    /**
     *
     * @type {number}
     * @memberof ThingList
     */
    'type_id': number;
    /**
     *
     * @type {string}
     * @memberof ThingList
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof ThingList
     */
    'description'?: string;
    /**
     *
     * @type {number}
     * @memberof ThingList
     */
    'external_id'?: number;
    /**
     *
     * @type {boolean}
     * @memberof ThingList
     */
    'inactivated': boolean;
    /**
     *
     * @type {boolean}
     * @memberof ThingList
     */
    'validated'?: boolean;
    /**
     *
     * @type {ThingStatus}
     * @memberof ThingList
     */
    'status'?: ThingStatus;
    /**
     *
     * @type {number}
     * @memberof ThingList
     */
    'created_by': number;
    /**
     *
     * @type {string}
     * @memberof ThingList
     */
    'created_at'?: string;
    /**
     *
     * @type {number}
     * @memberof ThingList
     */
    'pos_x': number;
    /**
     *
     * @type {number}
     * @memberof ThingList
     */
    'pos_y': number;
}


/**
 *
 * @export
 * @enum {string}
 */

export const ThingStatus = {
    Planifi: 'Planifié',
    EnConstruction: 'En Construction',
    Utilis: 'Utilisé',
    Abandonn: 'Abandonné',
    Dmoli: 'Démoli'
} as const;

export type ThingStatus = typeof ThingStatus[keyof typeof ThingStatus];


/**
 *
 * @export
 * @interface TypeThing
 */
export interface TypeThing {
    /**
     *
     * @type {number}
     * @memberof TypeThing
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof TypeThing
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof TypeThing
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof TypeThing
     */
    'comment'?: string;
    /**
     *
     * @type {number}
     * @memberof TypeThing
     */
    'external_id'?: number;
    /**
     *
     * @type {string}
     * @memberof TypeThing
     */
    'table_name'?: string;
    /**
     *
     * @type {string}
     * @memberof TypeThing
     */
    'geometry_type'?: string;
    /**
     *
     * @type {boolean}
     * @memberof TypeThing
     */
    'inactivated': boolean;
    /**
     *
     * @type {string}
     * @memberof TypeThing
     */
    'inactivated_time'?: string;
    /**
     *
     * @type {number}
     * @memberof TypeThing
     */
    'inactivated_by'?: number;
    /**
     *
     * @type {string}
     * @memberof TypeThing
     */
    'inactivated_reason'?: string;
    /**
     *
     * @type {number}
     * @memberof TypeThing
     */
    'managed_by'?: number;
    /**
     *
     * @type {string}
     * @memberof TypeThing
     */
    'created_at'?: string;
    /**
     *
     * @type {number}
     * @memberof TypeThing
     */
    'created_by': number;
    /**
     *
     * @type {string}
     * @memberof TypeThing
     */
    'last_modified_at'?: string;
    /**
     *
     * @type {number}
     * @memberof TypeThing
     */
    'last_modified_by'?: number;
    /**
     *
     * @type {boolean}
     * @memberof TypeThing
     */
    'deleted': boolean;
    /**
     *
     * @type {string}
     * @memberof TypeThing
     */
    'deleted_at'?: string;
    /**
     *
     * @type {number}
     * @memberof TypeThing
     */
    'deleted_by'?: number;
    /**
     *
     * @type {any}
     * @memberof TypeThing
     */
    'more_data_schema'?: any;
}
/**
 *
 * @export
 * @interface TypeThingList
 */
export interface TypeThingList {
    /**
     *
     * @type {number}
     * @memberof TypeThingList
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof TypeThingList
     */
    'name': string;
    /**
     *
     * @type {number}
     * @memberof TypeThingList
     */
    'external_id'?: number;
    /**
     *
     * @type {string}
     * @memberof TypeThingList
     */
    'created_at': string;
    /**
     *
     * @type {string}
     * @memberof TypeThingList
     */
    'table_name'?: string;
    /**
     *
     * @type {string}
     * @memberof TypeThingList
     */
    'geometry_type'?: string;
    /**
     *
     * @type {boolean}
     * @memberof TypeThingList
     */
    'inactivated': boolean;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete a thing
         * @summary Delete allows to delete a specific thingId
         * @param {string} thingId Id of the thing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (thingId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'thingId' is not null or undefined
            assertParamExists('_delete', 'thingId', thingId)
            const localVarPath = `/thing/{thingId}`
                .replace(`{${"thingId"}}`, encodeURIComponent(String(thingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the number of things found after filtering with passed criterias
         * @summary Count returns the number of thing based on search criterias
         * @param {string} [keywords] text keywords to filter the things to return
         * @param {number} [type] TypeThing id to filter by the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {boolean} [validated] validation flag to filter the things to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        count: async (keywords?: string, type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thing/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (inactivated !== undefined) {
                localVarQueryParameter['inactivated'] = inactivated;
            }

            if (validated !== undefined) {
                localVarQueryParameter['validated'] = validated;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new thing
         * @summary Create will create a new thing
         * @param {Thing} thing Thing to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (thing: Thing, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'thing' is not null or undefined
            assertParamExists('create', 'thing', thing)
            const localVarPath = `/thing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(thing, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific thing
         * @summary Get will retrieve in backend all information about a specific thingId
         * @param {string} thingId Id of the thing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (thingId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'thingId' is not null or undefined
            assertParamExists('get', 'thingId', thingId)
            const localVarPath = `/thing/{thingId}`
                .replace(`{${"thingId"}}`, encodeURIComponent(String(thingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the thing in an array
         * @summary List returns a list of thing
         * @param {number} [type] TypeThing id to filter by the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {boolean} [validated] validation flag to filter the things to return
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (inactivated !== undefined) {
                localVarQueryParameter['inactivated'] = inactivated;
            }

            if (validated !== undefined) {
                localVarQueryParameter['validated'] = validated;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the things in an array
         * @summary ListByExternalId returns a list of thing filtered by externalId
         * @param {number} externalId externalId of the things needed
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listByExternalId: async (externalId: number, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalId' is not null or undefined
            assertParamExists('listByExternalId', 'externalId', externalId)
            const localVarPath = `/thing/by-external-id/{externalId}`
                .replace(`{${"externalId"}}`, encodeURIComponent(String(externalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the thing in an array
         * @summary Search returns a list of thing based on search criterias
         * @param {string} [keywords] text keywords to filter the things to return
         * @param {number} [type] TypeThing id to filter by the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {boolean} [validated] validation flag to filter the things to return
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (keywords?: string, type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thing/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (inactivated !== undefined) {
                localVarQueryParameter['inactivated'] = inactivated;
            }

            if (validated !== undefined) {
                localVarQueryParameter['validated'] = validated;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the number of TypeThings found after filtering with passed criterias
         * @summary Count returns the number of TypeThing based on search criterias
         * @param {string} [keywords] text keywords to filter the TypeThing count
         * @param {number} [createdBy] id of the creator to filter the TypeThing count
         * @param {boolean} [inactivated] inactivated flag to filter the TypeThing count to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeThingCount: async (keywords?: string, createdBy?: number, inactivated?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/types/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (inactivated !== undefined) {
                localVarQueryParameter['inactivated'] = inactivated;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new group
         * @summary TypeThingCreate will create a new group
         * @param {TypeThing} typeThing TypeThing to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeThingCreate: async (typeThing: TypeThing, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeThing' is not null or undefined
            assertParamExists('typeThingCreate', 'typeThing', typeThing)
            const localVarPath = `/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typeThing, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a typeThing
         * @summary TypeThingDelete allows to delete a specific typeThingId
         * @param {number} typeThingId Id of the typeThing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeThingDelete: async (typeThingId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeThingId' is not null or undefined
            assertParamExists('typeThingDelete', 'typeThingId', typeThingId)
            const localVarPath = `/types/{typeThingId}`
                .replace(`{${"typeThingId"}}`, encodeURIComponent(String(typeThingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific typeThing
         * @summary TypeThingGet will retrieve in backend all information about a specific typeThingId
         * @param {number} typeThingId Id of the typeThing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeThingGet: async (typeThingId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeThingId' is not null or undefined
            assertParamExists('typeThingGet', 'typeThingId', typeThingId)
            const localVarPath = `/types/{typeThingId}`
                .replace(`{${"typeThingId"}}`, encodeURIComponent(String(typeThingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the types in an array
         * @summary TypeThingList returns a list of types
         * @param {string} [keywords] text keywords to filter the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {number} [externalId] id of the external id to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeThingList: async (keywords?: string, createdBy?: number, externalId?: number, inactivated?: boolean, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (externalId !== undefined) {
                localVarQueryParameter['external_id'] = externalId;
            }

            if (inactivated !== undefined) {
                localVarQueryParameter['inactivated'] = inactivated;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the information related to a typeThing
         * @summary TypeThingUpdate allows to modify information about a specific typeThingId
         * @param {number} typeThingId Id of the typeThing
         * @param {number} id
         * @param {string} name
         * @param {boolean} inactivated
         * @param {number} createdBy
         * @param {boolean} deleted
         * @param {string} [description]
         * @param {string} [comment]
         * @param {number} [externalId]
         * @param {string} [tableName]
         * @param {string} [geometryType]
         * @param {string} [inactivatedTime]
         * @param {number} [inactivatedBy]
         * @param {string} [inactivatedReason]
         * @param {number} [managedBy]
         * @param {string} [createdAt]
         * @param {string} [lastModifiedAt]
         * @param {number} [lastModifiedBy]
         * @param {string} [deletedAt]
         * @param {number} [deletedBy]
         * @param {any} [moreDataSchema]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeThingUpdate: async (typeThingId: number, id: number, name: string, inactivated: boolean, createdBy: number, deleted: boolean, description?: string, comment?: string, externalId?: number, tableName?: string, geometryType?: string, inactivatedTime?: string, inactivatedBy?: number, inactivatedReason?: string, managedBy?: number, createdAt?: string, lastModifiedAt?: string, lastModifiedBy?: number, deletedAt?: string, deletedBy?: number, moreDataSchema?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeThingId' is not null or undefined
            assertParamExists('typeThingUpdate', 'typeThingId', typeThingId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('typeThingUpdate', 'id', id)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('typeThingUpdate', 'name', name)
            // verify required parameter 'inactivated' is not null or undefined
            assertParamExists('typeThingUpdate', 'inactivated', inactivated)
            // verify required parameter 'createdBy' is not null or undefined
            assertParamExists('typeThingUpdate', 'createdBy', createdBy)
            // verify required parameter 'deleted' is not null or undefined
            assertParamExists('typeThingUpdate', 'deleted', deleted)
            const localVarPath = `/types/{typeThingId}`
                .replace(`{${"typeThingId"}}`, encodeURIComponent(String(typeThingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication JWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (id !== undefined) {
                localVarFormParams.set('id', id as any);
            }

            if (name !== undefined) {
                localVarFormParams.set('name', name as any);
            }

            if (description !== undefined) {
                localVarFormParams.set('description', description as any);
            }

            if (comment !== undefined) {
                localVarFormParams.set('comment', comment as any);
            }

            if (externalId !== undefined) {
                localVarFormParams.set('external_id', externalId as any);
            }

            if (tableName !== undefined) {
                localVarFormParams.set('table_name', tableName as any);
            }

            if (geometryType !== undefined) {
                localVarFormParams.set('geometry_type', geometryType as any);
            }

            if (inactivated !== undefined) {
                localVarFormParams.set('inactivated', inactivated as any);
            }

            if (inactivatedTime !== undefined) {
                localVarFormParams.set('inactivated_time', inactivatedTime as any);
            }

            if (inactivatedBy !== undefined) {
                localVarFormParams.set('inactivated_by', inactivatedBy as any);
            }

            if (inactivatedReason !== undefined) {
                localVarFormParams.set('inactivated_reason', inactivatedReason as any);
            }

            if (managedBy !== undefined) {
                localVarFormParams.set('managed_by', managedBy as any);
            }

            if (createdAt !== undefined) {
                localVarFormParams.set('created_at', createdAt as any);
            }

            if (createdBy !== undefined) {
                localVarFormParams.set('created_by', createdBy as any);
            }

            if (lastModifiedAt !== undefined) {
                localVarFormParams.set('last_modified_at', lastModifiedAt as any);
            }

            if (lastModifiedBy !== undefined) {
                localVarFormParams.set('last_modified_by', lastModifiedBy as any);
            }

            if (deleted !== undefined) {
                localVarFormParams.set('deleted', deleted as any);
            }

            if (deletedAt !== undefined) {
                localVarFormParams.set('deleted_at', deletedAt as any);
            }

            if (deletedBy !== undefined) {
                localVarFormParams.set('deleted_by', deletedBy as any);
            }

            if (moreDataSchema !== undefined) {
                localVarFormParams.set('more_data_schema', moreDataSchema as any);
            }


            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the status of a thing
         * @summary Update allows to modify information about a specific thingId
         * @param {string} thingId Id of the thing
         * @param {string} id cet Universally unique identifier (UUID) sera généré automatiquement pour vous
         * @param {number} typeId FK sur la clé primaire du TypeThing de cet objet
         * @param {string} name
         * @param {boolean} inactivated
         * @param {number} createdBy identifiant de l\\\&#39;utilisateur ayant créé cet enregistrement
         * @param {boolean} deleted cet enregisrement a été marqué comme effacé
         * @param {number} posX
         * @param {number} posY
         * @param {string} [description]
         * @param {string} [comment]
         * @param {number} [externalId]
         * @param {string} [externalRef]
         * @param {string} [buildAt]
         * @param {ThingStatus} [status]
         * @param {string} [containedBy]
         * @param {number} [containedByOld]
         * @param {string} [inactivatedTime]
         * @param {number} [inactivatedBy]
         * @param {string} [inactivatedReason]
         * @param {boolean} [validated]
         * @param {string} [validatedTime]
         * @param {number} [validatedBy]
         * @param {number} [managedBy]
         * @param {string} [createdAt] date de création de cet enregistrement dans la base
         * @param {string} [lastModifiedAt] date de la dernière modication de cet enregistrement
         * @param {number} [lastModifiedBy] utilisateur ayant effectué la dernière modication de cet enregistrement
         * @param {string} [deletedAt] date à laquelle cet enregisrement a été marqué comme effacé
         * @param {number} [deletedBy] utilisateur ayant demandé de marquer cet enregisrement comme effacé
         * @param {object} [moreData] permet de stocker des attributs complémentaires au format json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (thingId: string, id: string, typeId: number, name: string, inactivated: boolean, createdBy: number, deleted: boolean, posX: number, posY: number, description?: string, comment?: string, externalId?: number, externalRef?: string, buildAt?: string, status?: ThingStatus, containedBy?: string, containedByOld?: number, inactivatedTime?: string, inactivatedBy?: number, inactivatedReason?: string, validated?: boolean, validatedTime?: string, validatedBy?: number, managedBy?: number, createdAt?: string, lastModifiedAt?: string, lastModifiedBy?: number, deletedAt?: string, deletedBy?: number, moreData?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'thingId' is not null or undefined
            assertParamExists('update', 'thingId', thingId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'typeId' is not null or undefined
            assertParamExists('update', 'typeId', typeId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('update', 'name', name)
            // verify required parameter 'inactivated' is not null or undefined
            assertParamExists('update', 'inactivated', inactivated)
            // verify required parameter 'createdBy' is not null or undefined
            assertParamExists('update', 'createdBy', createdBy)
            // verify required parameter 'deleted' is not null or undefined
            assertParamExists('update', 'deleted', deleted)
            // verify required parameter 'posX' is not null or undefined
            assertParamExists('update', 'posX', posX)
            // verify required parameter 'posY' is not null or undefined
            assertParamExists('update', 'posY', posY)
            const localVarPath = `/thing/{thingId}`
                .replace(`{${"thingId"}}`, encodeURIComponent(String(thingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication JWTAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (id !== undefined) {
                localVarFormParams.set('id', id as any);
            }

            if (typeId !== undefined) {
                localVarFormParams.set('type_id', typeId as any);
            }

            if (name !== undefined) {
                localVarFormParams.set('name', name as any);
            }

            if (description !== undefined) {
                localVarFormParams.set('description', description as any);
            }

            if (comment !== undefined) {
                localVarFormParams.set('comment', comment as any);
            }

            if (externalId !== undefined) {
                localVarFormParams.set('external_id', externalId as any);
            }

            if (externalRef !== undefined) {
                localVarFormParams.set('external_ref', externalRef as any);
            }

            if (buildAt !== undefined) {
                localVarFormParams.set('build_at', buildAt as any);
            }

            if (status !== undefined) {
                localVarFormParams.set('status', status as any);
            }

            if (containedBy !== undefined) {
                localVarFormParams.set('contained_by', containedBy as any);
            }

            if (containedByOld !== undefined) {
                localVarFormParams.set('contained_by_old', containedByOld as any);
            }

            if (inactivated !== undefined) {
                localVarFormParams.set('inactivated', inactivated as any);
            }

            if (inactivatedTime !== undefined) {
                localVarFormParams.set('inactivated_time', inactivatedTime as any);
            }

            if (inactivatedBy !== undefined) {
                localVarFormParams.set('inactivated_by', inactivatedBy as any);
            }

            if (inactivatedReason !== undefined) {
                localVarFormParams.set('inactivated_reason', inactivatedReason as any);
            }

            if (validated !== undefined) {
                localVarFormParams.set('validated', validated as any);
            }

            if (validatedTime !== undefined) {
                localVarFormParams.set('validated_time', validatedTime as any);
            }

            if (validatedBy !== undefined) {
                localVarFormParams.set('validated_by', validatedBy as any);
            }

            if (managedBy !== undefined) {
                localVarFormParams.set('managed_by', managedBy as any);
            }

            if (createdAt !== undefined) {
                localVarFormParams.set('created_at', createdAt as any);
            }

            if (createdBy !== undefined) {
                localVarFormParams.set('created_by', createdBy as any);
            }

            if (lastModifiedAt !== undefined) {
                localVarFormParams.set('last_modified_at', lastModifiedAt as any);
            }

            if (lastModifiedBy !== undefined) {
                localVarFormParams.set('last_modified_by', lastModifiedBy as any);
            }

            if (deleted !== undefined) {
                localVarFormParams.set('deleted', deleted as any);
            }

            if (deletedAt !== undefined) {
                localVarFormParams.set('deleted_at', deletedAt as any);
            }

            if (deletedBy !== undefined) {
                localVarFormParams.set('deleted_by', deletedBy as any);
            }

            if (moreData !== undefined) {
                localVarFormParams.set('more_data', moreData as any);
            }

            if (posX !== undefined) {
                localVarFormParams.set('pos_x', posX as any);
            }

            if (posY !== undefined) {
                localVarFormParams.set('pos_y', posY as any);
            }


            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * delete a thing
         * @summary Delete allows to delete a specific thingId
         * @param {string} thingId Id of the thing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(thingId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(thingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the number of things found after filtering with passed criterias
         * @summary Count returns the number of thing based on search criterias
         * @param {string} [keywords] text keywords to filter the things to return
         * @param {number} [type] TypeThing id to filter by the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {boolean} [validated] validation flag to filter the things to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async count(keywords?: string, type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.count(keywords, type, createdBy, inactivated, validated, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new thing
         * @summary Create will create a new thing
         * @param {Thing} thing Thing to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(thing: Thing, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Thing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(thing, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a specific thing
         * @summary Get will retrieve in backend all information about a specific thingId
         * @param {string} thingId Id of the thing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(thingId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Thing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(thingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the thing in an array
         * @summary List returns a list of thing
         * @param {number} [type] TypeThing id to filter by the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {boolean} [validated] validation flag to filter the things to return
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThingList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(type, createdBy, inactivated, validated, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the things in an array
         * @summary ListByExternalId returns a list of thing filtered by externalId
         * @param {number} externalId externalId of the things needed
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listByExternalId(externalId: number, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThingList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listByExternalId(externalId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the thing in an array
         * @summary Search returns a list of thing based on search criterias
         * @param {string} [keywords] text keywords to filter the things to return
         * @param {number} [type] TypeThing id to filter by the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {boolean} [validated] validation flag to filter the things to return
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(keywords?: string, type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThingList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(keywords, type, createdBy, inactivated, validated, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the number of TypeThings found after filtering with passed criterias
         * @summary Count returns the number of TypeThing based on search criterias
         * @param {string} [keywords] text keywords to filter the TypeThing count
         * @param {number} [createdBy] id of the creator to filter the TypeThing count
         * @param {boolean} [inactivated] inactivated flag to filter the TypeThing count to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeThingCount(keywords?: string, createdBy?: number, inactivated?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.typeThingCount(keywords, createdBy, inactivated, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new group
         * @summary TypeThingCreate will create a new group
         * @param {TypeThing} typeThing TypeThing to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeThingCreate(typeThing: TypeThing, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypeThing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.typeThingCreate(typeThing, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete a typeThing
         * @summary TypeThingDelete allows to delete a specific typeThingId
         * @param {number} typeThingId Id of the typeThing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeThingDelete(typeThingId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.typeThingDelete(typeThingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a specific typeThing
         * @summary TypeThingGet will retrieve in backend all information about a specific typeThingId
         * @param {number} typeThingId Id of the typeThing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeThingGet(typeThingId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypeThing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.typeThingGet(typeThingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the types in an array
         * @summary TypeThingList returns a list of types
         * @param {string} [keywords] text keywords to filter the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {number} [externalId] id of the external id to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeThingList(keywords?: string, createdBy?: number, externalId?: number, inactivated?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TypeThingList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.typeThingList(keywords, createdBy, externalId, inactivated, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the information related to a typeThing
         * @summary TypeThingUpdate allows to modify information about a specific typeThingId
         * @param {number} typeThingId Id of the typeThing
         * @param {number} id
         * @param {string} name
         * @param {boolean} inactivated
         * @param {number} createdBy
         * @param {boolean} deleted
         * @param {string} [description]
         * @param {string} [comment]
         * @param {number} [externalId]
         * @param {string} [tableName]
         * @param {string} [geometryType]
         * @param {string} [inactivatedTime]
         * @param {number} [inactivatedBy]
         * @param {string} [inactivatedReason]
         * @param {number} [managedBy]
         * @param {string} [createdAt]
         * @param {string} [lastModifiedAt]
         * @param {number} [lastModifiedBy]
         * @param {string} [deletedAt]
         * @param {number} [deletedBy]
         * @param {any} [moreDataSchema]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeThingUpdate(typeThingId: number, id: number, name: string, inactivated: boolean, createdBy: number, deleted: boolean, description?: string, comment?: string, externalId?: number, tableName?: string, geometryType?: string, inactivatedTime?: string, inactivatedBy?: number, inactivatedReason?: string, managedBy?: number, createdAt?: string, lastModifiedAt?: string, lastModifiedBy?: number, deletedAt?: string, deletedBy?: number, moreDataSchema?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypeThing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.typeThingUpdate(typeThingId, id, name, inactivated, createdBy, deleted, description, comment, externalId, tableName, geometryType, inactivatedTime, inactivatedBy, inactivatedReason, managedBy, createdAt, lastModifiedAt, lastModifiedBy, deletedAt, deletedBy, moreDataSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the status of a thing
         * @summary Update allows to modify information about a specific thingId
         * @param {string} thingId Id of the thing
         * @param {string} id cet Universally unique identifier (UUID) sera généré automatiquement pour vous
         * @param {number} typeId FK sur la clé primaire du TypeThing de cet objet
         * @param {string} name
         * @param {boolean} inactivated
         * @param {number} createdBy identifiant de l\\\&#39;utilisateur ayant créé cet enregistrement
         * @param {boolean} deleted cet enregisrement a été marqué comme effacé
         * @param {number} posX
         * @param {number} posY
         * @param {string} [description]
         * @param {string} [comment]
         * @param {number} [externalId]
         * @param {string} [externalRef]
         * @param {string} [buildAt]
         * @param {ThingStatus} [status]
         * @param {string} [containedBy]
         * @param {number} [containedByOld]
         * @param {string} [inactivatedTime]
         * @param {number} [inactivatedBy]
         * @param {string} [inactivatedReason]
         * @param {boolean} [validated]
         * @param {string} [validatedTime]
         * @param {number} [validatedBy]
         * @param {number} [managedBy]
         * @param {string} [createdAt] date de création de cet enregistrement dans la base
         * @param {string} [lastModifiedAt] date de la dernière modication de cet enregistrement
         * @param {number} [lastModifiedBy] utilisateur ayant effectué la dernière modication de cet enregistrement
         * @param {string} [deletedAt] date à laquelle cet enregisrement a été marqué comme effacé
         * @param {number} [deletedBy] utilisateur ayant demandé de marquer cet enregisrement comme effacé
         * @param {object} [moreData] permet de stocker des attributs complémentaires au format json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(thingId: string, id: string, typeId: number, name: string, inactivated: boolean, createdBy: number, deleted: boolean, posX: number, posY: number, description?: string, comment?: string, externalId?: number, externalRef?: string, buildAt?: string, status?: ThingStatus, containedBy?: string, containedByOld?: number, inactivatedTime?: string, inactivatedBy?: number, inactivatedReason?: string, validated?: boolean, validatedTime?: string, validatedBy?: number, managedBy?: number, createdAt?: string, lastModifiedAt?: string, lastModifiedBy?: number, deletedAt?: string, deletedBy?: number, moreData?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Thing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(thingId, id, typeId, name, inactivated, createdBy, deleted, posX, posY, description, comment, externalId, externalRef, buildAt, status, containedBy, containedByOld, inactivatedTime, inactivatedBy, inactivatedReason, validated, validatedTime, validatedBy, managedBy, createdAt, lastModifiedAt, lastModifiedBy, deletedAt, deletedBy, moreData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * delete a thing
         * @summary Delete allows to delete a specific thingId
         * @param {string} thingId Id of the thing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(thingId: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(thingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the number of things found after filtering with passed criterias
         * @summary Count returns the number of thing based on search criterias
         * @param {string} [keywords] text keywords to filter the things to return
         * @param {number} [type] TypeThing id to filter by the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {boolean} [validated] validation flag to filter the things to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        count(keywords?: string, type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, options?: any): AxiosPromise<number> {
            return localVarFp.count(keywords, type, createdBy, inactivated, validated, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new thing
         * @summary Create will create a new thing
         * @param {Thing} thing Thing to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(thing: Thing, options?: any): AxiosPromise<Thing> {
            return localVarFp.create(thing, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific thing
         * @summary Get will retrieve in backend all information about a specific thingId
         * @param {string} thingId Id of the thing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(thingId: string, options?: any): AxiosPromise<Thing> {
            return localVarFp.get(thingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the thing in an array
         * @summary List returns a list of thing
         * @param {number} [type] TypeThing id to filter by the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {boolean} [validated] validation flag to filter the things to return
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, limit?: number, offset?: number, options?: any): AxiosPromise<Array<ThingList>> {
            return localVarFp.list(type, createdBy, inactivated, validated, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the things in an array
         * @summary ListByExternalId returns a list of thing filtered by externalId
         * @param {number} externalId externalId of the things needed
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listByExternalId(externalId: number, limit?: number, offset?: number, options?: any): AxiosPromise<Array<ThingList>> {
            return localVarFp.listByExternalId(externalId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the thing in an array
         * @summary Search returns a list of thing based on search criterias
         * @param {string} [keywords] text keywords to filter the things to return
         * @param {number} [type] TypeThing id to filter by the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {boolean} [validated] validation flag to filter the things to return
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(keywords?: string, type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, limit?: number, offset?: number, options?: any): AxiosPromise<Array<ThingList>> {
            return localVarFp.search(keywords, type, createdBy, inactivated, validated, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the number of TypeThings found after filtering with passed criterias
         * @summary Count returns the number of TypeThing based on search criterias
         * @param {string} [keywords] text keywords to filter the TypeThing count
         * @param {number} [createdBy] id of the creator to filter the TypeThing count
         * @param {boolean} [inactivated] inactivated flag to filter the TypeThing count to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeThingCount(keywords?: string, createdBy?: number, inactivated?: boolean, options?: any): AxiosPromise<number> {
            return localVarFp.typeThingCount(keywords, createdBy, inactivated, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new group
         * @summary TypeThingCreate will create a new group
         * @param {TypeThing} typeThing TypeThing to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeThingCreate(typeThing: TypeThing, options?: any): AxiosPromise<TypeThing> {
            return localVarFp.typeThingCreate(typeThing, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a typeThing
         * @summary TypeThingDelete allows to delete a specific typeThingId
         * @param {number} typeThingId Id of the typeThing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeThingDelete(typeThingId: number, options?: any): AxiosPromise<void> {
            return localVarFp.typeThingDelete(typeThingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific typeThing
         * @summary TypeThingGet will retrieve in backend all information about a specific typeThingId
         * @param {number} typeThingId Id of the typeThing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeThingGet(typeThingId: number, options?: any): AxiosPromise<TypeThing> {
            return localVarFp.typeThingGet(typeThingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the types in an array
         * @summary TypeThingList returns a list of types
         * @param {string} [keywords] text keywords to filter the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {number} [externalId] id of the external id to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeThingList(keywords?: string, createdBy?: number, externalId?: number, inactivated?: boolean, limit?: number, offset?: number, options?: any): AxiosPromise<Array<TypeThingList>> {
            return localVarFp.typeThingList(keywords, createdBy, externalId, inactivated, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the information related to a typeThing
         * @summary TypeThingUpdate allows to modify information about a specific typeThingId
         * @param {number} typeThingId Id of the typeThing
         * @param {number} id
         * @param {string} name
         * @param {boolean} inactivated
         * @param {number} createdBy
         * @param {boolean} deleted
         * @param {string} [description]
         * @param {string} [comment]
         * @param {number} [externalId]
         * @param {string} [tableName]
         * @param {string} [geometryType]
         * @param {string} [inactivatedTime]
         * @param {number} [inactivatedBy]
         * @param {string} [inactivatedReason]
         * @param {number} [managedBy]
         * @param {string} [createdAt]
         * @param {string} [lastModifiedAt]
         * @param {number} [lastModifiedBy]
         * @param {string} [deletedAt]
         * @param {number} [deletedBy]
         * @param {any} [moreDataSchema]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeThingUpdate(typeThingId: number, id: number, name: string, inactivated: boolean, createdBy: number, deleted: boolean, description?: string, comment?: string, externalId?: number, tableName?: string, geometryType?: string, inactivatedTime?: string, inactivatedBy?: number, inactivatedReason?: string, managedBy?: number, createdAt?: string, lastModifiedAt?: string, lastModifiedBy?: number, deletedAt?: string, deletedBy?: number, moreDataSchema?: any, options?: any): AxiosPromise<TypeThing> {
            return localVarFp.typeThingUpdate(typeThingId, id, name, inactivated, createdBy, deleted, description, comment, externalId, tableName, geometryType, inactivatedTime, inactivatedBy, inactivatedReason, managedBy, createdAt, lastModifiedAt, lastModifiedBy, deletedAt, deletedBy, moreDataSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the status of a thing
         * @summary Update allows to modify information about a specific thingId
         * @param {string} thingId Id of the thing
         * @param {string} id cet Universally unique identifier (UUID) sera généré automatiquement pour vous
         * @param {number} typeId FK sur la clé primaire du TypeThing de cet objet
         * @param {string} name
         * @param {boolean} inactivated
         * @param {number} createdBy identifiant de l\\\&#39;utilisateur ayant créé cet enregistrement
         * @param {boolean} deleted cet enregisrement a été marqué comme effacé
         * @param {number} posX
         * @param {number} posY
         * @param {string} [description]
         * @param {string} [comment]
         * @param {number} [externalId]
         * @param {string} [externalRef]
         * @param {string} [buildAt]
         * @param {ThingStatus} [status]
         * @param {string} [containedBy]
         * @param {number} [containedByOld]
         * @param {string} [inactivatedTime]
         * @param {number} [inactivatedBy]
         * @param {string} [inactivatedReason]
         * @param {boolean} [validated]
         * @param {string} [validatedTime]
         * @param {number} [validatedBy]
         * @param {number} [managedBy]
         * @param {string} [createdAt] date de création de cet enregistrement dans la base
         * @param {string} [lastModifiedAt] date de la dernière modication de cet enregistrement
         * @param {number} [lastModifiedBy] utilisateur ayant effectué la dernière modication de cet enregistrement
         * @param {string} [deletedAt] date à laquelle cet enregisrement a été marqué comme effacé
         * @param {number} [deletedBy] utilisateur ayant demandé de marquer cet enregisrement comme effacé
         * @param {object} [moreData] permet de stocker des attributs complémentaires au format json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(thingId: string, id: string, typeId: number, name: string, inactivated: boolean, createdBy: number, deleted: boolean, posX: number, posY: number, description?: string, comment?: string, externalId?: number, externalRef?: string, buildAt?: string, status?: ThingStatus, containedBy?: string, containedByOld?: number, inactivatedTime?: string, inactivatedBy?: number, inactivatedReason?: string, validated?: boolean, validatedTime?: string, validatedBy?: number, managedBy?: number, createdAt?: string, lastModifiedAt?: string, lastModifiedBy?: number, deletedAt?: string, deletedBy?: number, moreData?: object, options?: any): AxiosPromise<Thing> {
            return localVarFp.update(thingId, id, typeId, name, inactivated, createdBy, deleted, posX, posY, description, comment, externalId, externalRef, buildAt, status, containedBy, containedByOld, inactivatedTime, inactivatedBy, inactivatedReason, validated, validatedTime, validatedBy, managedBy, createdAt, lastModifiedAt, lastModifiedBy, deletedAt, deletedBy, moreData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * delete a thing
     * @summary Delete allows to delete a specific thingId
     * @param {string} thingId Id of the thing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _delete(thingId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration)._delete(thingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the number of things found after filtering with passed criterias
     * @summary Count returns the number of thing based on search criterias
     * @param {string} [keywords] text keywords to filter the things to return
     * @param {number} [type] TypeThing id to filter by the things to return
     * @param {number} [createdBy] id of the creator to filter by the things to return
     * @param {boolean} [inactivated] inactivated flag to filter the things to return
     * @param {boolean} [validated] validation flag to filter the things to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public count(keywords?: string, type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).count(keywords, type, createdBy, inactivated, validated, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new thing
     * @summary Create will create a new thing
     * @param {Thing} thing Thing to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public create(thing: Thing, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).create(thing, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific thing
     * @summary Get will retrieve in backend all information about a specific thingId
     * @param {string} thingId Id of the thing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public get(thingId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).get(thingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the thing in an array
     * @summary List returns a list of thing
     * @param {number} [type] TypeThing id to filter by the things to return
     * @param {number} [createdBy] id of the creator to filter by the things to return
     * @param {boolean} [inactivated] inactivated flag to filter the things to return
     * @param {boolean} [validated] validation flag to filter the things to return
     * @param {number} [limit] maximum number of results to return
     * @param {number} [offset] offset rows to skip before returning rows
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public list(type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).list(type, createdBy, inactivated, validated, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the things in an array
     * @summary ListByExternalId returns a list of thing filtered by externalId
     * @param {number} externalId externalId of the things needed
     * @param {number} [limit] maximum number of results to return
     * @param {number} [offset] offset rows to skip before returning rows
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listByExternalId(externalId: number, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listByExternalId(externalId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the thing in an array
     * @summary Search returns a list of thing based on search criterias
     * @param {string} [keywords] text keywords to filter the things to return
     * @param {number} [type] TypeThing id to filter by the things to return
     * @param {number} [createdBy] id of the creator to filter by the things to return
     * @param {boolean} [inactivated] inactivated flag to filter the things to return
     * @param {boolean} [validated] validation flag to filter the things to return
     * @param {number} [limit] maximum number of results to return
     * @param {number} [offset] offset rows to skip before returning rows
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public search(keywords?: string, type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).search(keywords, type, createdBy, inactivated, validated, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the number of TypeThings found after filtering with passed criterias
     * @summary Count returns the number of TypeThing based on search criterias
     * @param {string} [keywords] text keywords to filter the TypeThing count
     * @param {number} [createdBy] id of the creator to filter the TypeThing count
     * @param {boolean} [inactivated] inactivated flag to filter the TypeThing count to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public typeThingCount(keywords?: string, createdBy?: number, inactivated?: boolean, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).typeThingCount(keywords, createdBy, inactivated, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new group
     * @summary TypeThingCreate will create a new group
     * @param {TypeThing} typeThing TypeThing to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public typeThingCreate(typeThing: TypeThing, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).typeThingCreate(typeThing, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a typeThing
     * @summary TypeThingDelete allows to delete a specific typeThingId
     * @param {number} typeThingId Id of the typeThing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public typeThingDelete(typeThingId: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).typeThingDelete(typeThingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific typeThing
     * @summary TypeThingGet will retrieve in backend all information about a specific typeThingId
     * @param {number} typeThingId Id of the typeThing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public typeThingGet(typeThingId: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).typeThingGet(typeThingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the types in an array
     * @summary TypeThingList returns a list of types
     * @param {string} [keywords] text keywords to filter the things to return
     * @param {number} [createdBy] id of the creator to filter by the things to return
     * @param {number} [externalId] id of the external id to filter by the things to return
     * @param {boolean} [inactivated] inactivated flag to filter the things to return
     * @param {number} [limit] maximum number of results to return
     * @param {number} [offset] offset rows to skip before returning rows
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public typeThingList(keywords?: string, createdBy?: number, externalId?: number, inactivated?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).typeThingList(keywords, createdBy, externalId, inactivated, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the information related to a typeThing
     * @summary TypeThingUpdate allows to modify information about a specific typeThingId
     * @param {number} typeThingId Id of the typeThing
     * @param {number} id
     * @param {string} name
     * @param {boolean} inactivated
     * @param {number} createdBy
     * @param {boolean} deleted
     * @param {string} [description]
     * @param {string} [comment]
     * @param {number} [externalId]
     * @param {string} [tableName]
     * @param {string} [geometryType]
     * @param {string} [inactivatedTime]
     * @param {number} [inactivatedBy]
     * @param {string} [inactivatedReason]
     * @param {number} [managedBy]
     * @param {string} [createdAt]
     * @param {string} [lastModifiedAt]
     * @param {number} [lastModifiedBy]
     * @param {string} [deletedAt]
     * @param {number} [deletedBy]
     * @param {any} [moreDataSchema]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public typeThingUpdate(typeThingId: number, id: number, name: string, inactivated: boolean, createdBy: number, deleted: boolean, description?: string, comment?: string, externalId?: number, tableName?: string, geometryType?: string, inactivatedTime?: string, inactivatedBy?: number, inactivatedReason?: string, managedBy?: number, createdAt?: string, lastModifiedAt?: string, lastModifiedBy?: number, deletedAt?: string, deletedBy?: number, moreDataSchema?: any, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).typeThingUpdate(typeThingId, id, name, inactivated, createdBy, deleted, description, comment, externalId, tableName, geometryType, inactivatedTime, inactivatedBy, inactivatedReason, managedBy, createdAt, lastModifiedAt, lastModifiedBy, deletedAt, deletedBy, moreDataSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the status of a thing
     * @summary Update allows to modify information about a specific thingId
     * @param {string} thingId Id of the thing
     * @param {string} id cet Universally unique identifier (UUID) sera généré automatiquement pour vous
     * @param {number} typeId FK sur la clé primaire du TypeThing de cet objet
     * @param {string} name
     * @param {boolean} inactivated
     * @param {number} createdBy identifiant de l\\\&#39;utilisateur ayant créé cet enregistrement
     * @param {boolean} deleted cet enregisrement a été marqué comme effacé
     * @param {number} posX
     * @param {number} posY
     * @param {string} [description]
     * @param {string} [comment]
     * @param {number} [externalId]
     * @param {string} [externalRef]
     * @param {string} [buildAt]
     * @param {ThingStatus} [status]
     * @param {string} [containedBy]
     * @param {number} [containedByOld]
     * @param {string} [inactivatedTime]
     * @param {number} [inactivatedBy]
     * @param {string} [inactivatedReason]
     * @param {boolean} [validated]
     * @param {string} [validatedTime]
     * @param {number} [validatedBy]
     * @param {number} [managedBy]
     * @param {string} [createdAt] date de création de cet enregistrement dans la base
     * @param {string} [lastModifiedAt] date de la dernière modication de cet enregistrement
     * @param {number} [lastModifiedBy] utilisateur ayant effectué la dernière modication de cet enregistrement
     * @param {string} [deletedAt] date à laquelle cet enregisrement a été marqué comme effacé
     * @param {number} [deletedBy] utilisateur ayant demandé de marquer cet enregisrement comme effacé
     * @param {object} [moreData] permet de stocker des attributs complémentaires au format json
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public update(thingId: string, id: string, typeId: number, name: string, inactivated: boolean, createdBy: number, deleted: boolean, posX: number, posY: number, description?: string, comment?: string, externalId?: number, externalRef?: string, buildAt?: string, status?: ThingStatus, containedBy?: string, containedByOld?: number, inactivatedTime?: string, inactivatedBy?: number, inactivatedReason?: string, validated?: boolean, validatedTime?: string, validatedBy?: number, managedBy?: number, createdAt?: string, lastModifiedAt?: string, lastModifiedBy?: number, deletedAt?: string, deletedBy?: number, moreData?: object, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).update(thingId, id, typeId, name, inactivated, createdBy, deleted, posX, posY, description, comment, externalId, externalRef, buildAt, status, containedBy, containedByOld, inactivatedTime, inactivatedBy, inactivatedReason, validated, validatedTime, validatedBy, managedBy, createdAt, lastModifiedAt, lastModifiedBy, deletedAt, deletedBy, moreData, options).then((request) => request(this.axios, this.basePath));
    }
}



