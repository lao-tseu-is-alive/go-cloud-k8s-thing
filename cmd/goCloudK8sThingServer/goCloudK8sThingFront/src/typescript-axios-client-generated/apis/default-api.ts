/* tslint:disable */
/* eslint-disable */
/**
 * Thing microservice written in Golang
 * OpenApi Specification for an API to manage Thing
 *
 * OpenAPI spec version: 0.0.5
 * Contact: go-cloud-k8s-thing@goeland.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { Thing } from '../models';
import { ThingList } from '../models';
import { ThingStatus } from '../models';
import { TypeThing } from '../models';
import { TypeThingList } from '../models';
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete a thing
         * @summary Delete allows to delete a specific thingId
         * @param {string} thingId Id of the thing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (thingId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'thingId' is not null or undefined
            if (thingId === null || thingId === undefined) {
                throw new RequiredError('thingId','Required parameter thingId was null or undefined when calling _delete.');
            }
            const localVarPath = `/thing/{thingId}`
                .replace(`{${"thingId"}}`, encodeURIComponent(String(thingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the number of things found after filtering with passed criterias
         * @summary Count returns the number of thing based on search criterias
         * @param {string} [keywords] text keywords to filter the things to return
         * @param {number} [type] TypeThing id to filter by the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {boolean} [validated] validation flag to filter the things to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        count: async (keywords?: string, type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thing/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (inactivated !== undefined) {
                localVarQueryParameter['inactivated'] = inactivated;
            }

            if (validated !== undefined) {
                localVarQueryParameter['validated'] = validated;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new thing
         * @summary Create will create a new thing
         * @param {Thing} body Thing to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (body: Thing, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling create.');
            }
            const localVarPath = `/thing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific thing
         * @summary Get will retrieve in backend all information about a specific thingId
         * @param {string} thingId Id of the thing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (thingId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'thingId' is not null or undefined
            if (thingId === null || thingId === undefined) {
                throw new RequiredError('thingId','Required parameter thingId was null or undefined when calling get.');
            }
            const localVarPath = `/thing/{thingId}`
                .replace(`{${"thingId"}}`, encodeURIComponent(String(thingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the thing in an array
         * @summary List returns a list of thing
         * @param {number} [type] TypeThing id to filter by the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {boolean} [validated] validation flag to filter the things to return
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (inactivated !== undefined) {
                localVarQueryParameter['inactivated'] = inactivated;
            }

            if (validated !== undefined) {
                localVarQueryParameter['validated'] = validated;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the things in an array
         * @summary ListByExternalId returns a list of thing filtered by externalId
         * @param {number} externalId externalId of the things needed
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listByExternalId: async (externalId: number, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalId' is not null or undefined
            if (externalId === null || externalId === undefined) {
                throw new RequiredError('externalId','Required parameter externalId was null or undefined when calling listByExternalId.');
            }
            const localVarPath = `/thing/by-external-id/{externalId}`
                .replace(`{${"externalId"}}`, encodeURIComponent(String(externalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the thing in an array
         * @summary Search returns a list of thing based on search criterias
         * @param {string} [keywords] text keywords to filter the things to return
         * @param {number} [type] TypeThing id to filter by the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {boolean} [validated] validation flag to filter the things to return
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (keywords?: string, type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thing/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (inactivated !== undefined) {
                localVarQueryParameter['inactivated'] = inactivated;
            }

            if (validated !== undefined) {
                localVarQueryParameter['validated'] = validated;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the number of TypeThings found after filtering with passed criterias
         * @summary Count returns the number of TypeThing based on search criterias
         * @param {string} [keywords] text keywords to filter the TypeThing count
         * @param {number} [createdBy] id of the creator to filter the TypeThing count
         * @param {boolean} [inactivated] inactivated flag to filter the TypeThing count to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeThingCount: async (keywords?: string, createdBy?: number, inactivated?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/types/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (inactivated !== undefined) {
                localVarQueryParameter['inactivated'] = inactivated;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new group
         * @summary TypeThingCreate will create a new group
         * @param {TypeThing} body TypeThing to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeThingCreate: async (body: TypeThing, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling typeThingCreate.');
            }
            const localVarPath = `/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a typeThing
         * @summary TypeThingDelete allows to delete a specific typeThingId
         * @param {number} typeThingId Id of the typeThing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeThingDelete: async (typeThingId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeThingId' is not null or undefined
            if (typeThingId === null || typeThingId === undefined) {
                throw new RequiredError('typeThingId','Required parameter typeThingId was null or undefined when calling typeThingDelete.');
            }
            const localVarPath = `/types/{typeThingId}`
                .replace(`{${"typeThingId"}}`, encodeURIComponent(String(typeThingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific typeThing
         * @summary TypeThingGet will retrieve in backend all information about a specific typeThingId
         * @param {number} typeThingId Id of the typeThing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeThingGet: async (typeThingId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeThingId' is not null or undefined
            if (typeThingId === null || typeThingId === undefined) {
                throw new RequiredError('typeThingId','Required parameter typeThingId was null or undefined when calling typeThingGet.');
            }
            const localVarPath = `/types/{typeThingId}`
                .replace(`{${"typeThingId"}}`, encodeURIComponent(String(typeThingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the types in an array
         * @summary TypeThingList returns a list of types
         * @param {string} [keywords] text keywords to filter the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {number} [externalId] id of the external id to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeThingList: async (keywords?: string, createdBy?: number, externalId?: number, inactivated?: boolean, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (externalId !== undefined) {
                localVarQueryParameter['external_id'] = externalId;
            }

            if (inactivated !== undefined) {
                localVarQueryParameter['inactivated'] = inactivated;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the information related to a typeThing
         * @summary TypeThingUpdate allows to modify information about a specific typeThingId
         * @param {number} typeThingId Id of the typeThing
         * @param {number} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [comment] 
         * @param {number} [externalId] 
         * @param {string} [tableName] 
         * @param {string} [geometryType] 
         * @param {boolean} [inactivated] 
         * @param {Date} [inactivatedTime] 
         * @param {number} [inactivatedBy] 
         * @param {string} [inactivatedReason] 
         * @param {number} [managedBy] 
         * @param {Date} [createdAt] 
         * @param {number} [createdBy] 
         * @param {Date} [lastModifiedAt] 
         * @param {number} [lastModifiedBy] 
         * @param {boolean} [deleted] 
         * @param {Date} [deletedAt] 
         * @param {number} [deletedBy] 
         * @param {any} [moreDataSchema] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeThingUpdateForm: async (typeThingId: number, id?: number, name?: string, description?: string, comment?: string, externalId?: number, tableName?: string, geometryType?: string, inactivated?: boolean, inactivatedTime?: Date, inactivatedBy?: number, inactivatedReason?: string, managedBy?: number, createdAt?: Date, createdBy?: number, lastModifiedAt?: Date, lastModifiedBy?: number, deleted?: boolean, deletedAt?: Date, deletedBy?: number, moreDataSchema?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeThingId' is not null or undefined
            if (typeThingId === null || typeThingId === undefined) {
                throw new RequiredError('typeThingId','Required parameter typeThingId was null or undefined when calling typeThingUpdateForm.');
            }
            const localVarPath = `/types/{typeThingId}`
                .replace(`{${"typeThingId"}}`, encodeURIComponent(String(typeThingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (id !== undefined) { 
                localVarFormParams.set('id', id as any);
            }

            if (name !== undefined) { 
                localVarFormParams.set('name', name as any);
            }

            if (description !== undefined) { 
                localVarFormParams.set('description', description as any);
            }

            if (comment !== undefined) { 
                localVarFormParams.set('comment', comment as any);
            }

            if (externalId !== undefined) { 
                localVarFormParams.set('external_id', externalId as any);
            }

            if (tableName !== undefined) { 
                localVarFormParams.set('table_name', tableName as any);
            }

            if (geometryType !== undefined) { 
                localVarFormParams.set('geometry_type', geometryType as any);
            }

            if (inactivated !== undefined) { 
                localVarFormParams.set('inactivated', inactivated as any);
            }

            if (inactivatedTime !== undefined) { 
                localVarFormParams.set('inactivated_time', inactivatedTime as any);
            }

            if (inactivatedBy !== undefined) { 
                localVarFormParams.set('inactivated_by', inactivatedBy as any);
            }

            if (inactivatedReason !== undefined) { 
                localVarFormParams.set('inactivated_reason', inactivatedReason as any);
            }

            if (managedBy !== undefined) { 
                localVarFormParams.set('managed_by', managedBy as any);
            }

            if (createdAt !== undefined) { 
                localVarFormParams.set('created_at', createdAt as any);
            }

            if (createdBy !== undefined) { 
                localVarFormParams.set('created_by', createdBy as any);
            }

            if (lastModifiedAt !== undefined) { 
                localVarFormParams.set('last_modified_at', lastModifiedAt as any);
            }

            if (lastModifiedBy !== undefined) { 
                localVarFormParams.set('last_modified_by', lastModifiedBy as any);
            }

            if (deleted !== undefined) { 
                localVarFormParams.set('deleted', deleted as any);
            }

            if (deletedAt !== undefined) { 
                localVarFormParams.set('deleted_at', deletedAt as any);
            }

            if (deletedBy !== undefined) { 
                localVarFormParams.set('deleted_by', deletedBy as any);
            }

            if (moreDataSchema !== undefined) { 
                localVarFormParams.set('more_data_schema', moreDataSchema as any);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the status of a thing
         * @summary Update allows to modify information about a specific thingId
         * @param {string} thingId Id of the thing
         * @param {string} [id] 
         * @param {number} [typeId] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [comment] 
         * @param {number} [externalId] 
         * @param {string} [externalRef] 
         * @param {string} [buildAt] 
         * @param {ThingStatus} [status] 
         * @param {string} [containedBy] 
         * @param {number} [containedByOld] 
         * @param {boolean} [inactivated] 
         * @param {Date} [inactivatedTime] 
         * @param {number} [inactivatedBy] 
         * @param {string} [inactivatedReason] 
         * @param {boolean} [validated] 
         * @param {Date} [validatedTime] 
         * @param {number} [validatedBy] 
         * @param {number} [managedBy] 
         * @param {Date} [createdAt] 
         * @param {number} [createdBy] 
         * @param {Date} [lastModifiedAt] 
         * @param {number} [lastModifiedBy] 
         * @param {boolean} [deleted] 
         * @param {Date} [deletedAt] 
         * @param {number} [deletedBy] 
         * @param {any} [moreData] 
         * @param {number} [posX] 
         * @param {number} [posY] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateForm: async (thingId: string, id?: string, typeId?: number, name?: string, description?: string, comment?: string, externalId?: number, externalRef?: string, buildAt?: string, status?: ThingStatus, containedBy?: string, containedByOld?: number, inactivated?: boolean, inactivatedTime?: Date, inactivatedBy?: number, inactivatedReason?: string, validated?: boolean, validatedTime?: Date, validatedBy?: number, managedBy?: number, createdAt?: Date, createdBy?: number, lastModifiedAt?: Date, lastModifiedBy?: number, deleted?: boolean, deletedAt?: Date, deletedBy?: number, moreData?: any, posX?: number, posY?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'thingId' is not null or undefined
            if (thingId === null || thingId === undefined) {
                throw new RequiredError('thingId','Required parameter thingId was null or undefined when calling updateForm.');
            }
            const localVarPath = `/thing/{thingId}`
                .replace(`{${"thingId"}}`, encodeURIComponent(String(thingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication JWTAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (id !== undefined) { 
                localVarFormParams.set('id', id as any);
            }

            if (typeId !== undefined) { 
                localVarFormParams.set('type_id', typeId as any);
            }

            if (name !== undefined) { 
                localVarFormParams.set('name', name as any);
            }

            if (description !== undefined) { 
                localVarFormParams.set('description', description as any);
            }

            if (comment !== undefined) { 
                localVarFormParams.set('comment', comment as any);
            }

            if (externalId !== undefined) { 
                localVarFormParams.set('external_id', externalId as any);
            }

            if (externalRef !== undefined) { 
                localVarFormParams.set('external_ref', externalRef as any);
            }

            if (buildAt !== undefined) { 
                localVarFormParams.set('build_at', buildAt as any);
            }

            if (status !== undefined) { 
                localVarFormParams.set('status', status as any);
            }

            if (containedBy !== undefined) { 
                localVarFormParams.set('contained_by', containedBy as any);
            }

            if (containedByOld !== undefined) { 
                localVarFormParams.set('contained_by_old', containedByOld as any);
            }

            if (inactivated !== undefined) { 
                localVarFormParams.set('inactivated', inactivated as any);
            }

            if (inactivatedTime !== undefined) { 
                localVarFormParams.set('inactivated_time', inactivatedTime as any);
            }

            if (inactivatedBy !== undefined) { 
                localVarFormParams.set('inactivated_by', inactivatedBy as any);
            }

            if (inactivatedReason !== undefined) { 
                localVarFormParams.set('inactivated_reason', inactivatedReason as any);
            }

            if (validated !== undefined) { 
                localVarFormParams.set('validated', validated as any);
            }

            if (validatedTime !== undefined) { 
                localVarFormParams.set('validated_time', validatedTime as any);
            }

            if (validatedBy !== undefined) { 
                localVarFormParams.set('validated_by', validatedBy as any);
            }

            if (managedBy !== undefined) { 
                localVarFormParams.set('managed_by', managedBy as any);
            }

            if (createdAt !== undefined) { 
                localVarFormParams.set('created_at', createdAt as any);
            }

            if (createdBy !== undefined) { 
                localVarFormParams.set('created_by', createdBy as any);
            }

            if (lastModifiedAt !== undefined) { 
                localVarFormParams.set('last_modified_at', lastModifiedAt as any);
            }

            if (lastModifiedBy !== undefined) { 
                localVarFormParams.set('last_modified_by', lastModifiedBy as any);
            }

            if (deleted !== undefined) { 
                localVarFormParams.set('deleted', deleted as any);
            }

            if (deletedAt !== undefined) { 
                localVarFormParams.set('deleted_at', deletedAt as any);
            }

            if (deletedBy !== undefined) { 
                localVarFormParams.set('deleted_by', deletedBy as any);
            }

            if (moreData !== undefined) { 
                localVarFormParams.set('more_data', moreData as any);
            }

            if (posX !== undefined) { 
                localVarFormParams.set('pos_x', posX as any);
            }

            if (posY !== undefined) { 
                localVarFormParams.set('pos_y', posY as any);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * delete a thing
         * @summary Delete allows to delete a specific thingId
         * @param {string} thingId Id of the thing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(thingId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration)._delete(thingId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the number of things found after filtering with passed criterias
         * @summary Count returns the number of thing based on search criterias
         * @param {string} [keywords] text keywords to filter the things to return
         * @param {number} [type] TypeThing id to filter by the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {boolean} [validated] validation flag to filter the things to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async count(keywords?: string, type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<number>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).count(keywords, type, createdBy, inactivated, validated, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new thing
         * @summary Create will create a new thing
         * @param {Thing} body Thing to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(body: Thing, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Thing>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).create(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a specific thing
         * @summary Get will retrieve in backend all information about a specific thingId
         * @param {string} thingId Id of the thing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(thingId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Thing>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).get(thingId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the thing in an array
         * @summary List returns a list of thing
         * @param {number} [type] TypeThing id to filter by the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {boolean} [validated] validation flag to filter the things to return
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<ThingList>>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).list(type, createdBy, inactivated, validated, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the things in an array
         * @summary ListByExternalId returns a list of thing filtered by externalId
         * @param {number} externalId externalId of the things needed
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listByExternalId(externalId: number, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<ThingList>>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listByExternalId(externalId, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the thing in an array
         * @summary Search returns a list of thing based on search criterias
         * @param {string} [keywords] text keywords to filter the things to return
         * @param {number} [type] TypeThing id to filter by the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {boolean} [validated] validation flag to filter the things to return
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(keywords?: string, type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<ThingList>>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).search(keywords, type, createdBy, inactivated, validated, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the number of TypeThings found after filtering with passed criterias
         * @summary Count returns the number of TypeThing based on search criterias
         * @param {string} [keywords] text keywords to filter the TypeThing count
         * @param {number} [createdBy] id of the creator to filter the TypeThing count
         * @param {boolean} [inactivated] inactivated flag to filter the TypeThing count to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeThingCount(keywords?: string, createdBy?: number, inactivated?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<number>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).typeThingCount(keywords, createdBy, inactivated, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new group
         * @summary TypeThingCreate will create a new group
         * @param {TypeThing} body TypeThing to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeThingCreate(body: TypeThing, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TypeThing>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).typeThingCreate(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * delete a typeThing
         * @summary TypeThingDelete allows to delete a specific typeThingId
         * @param {number} typeThingId Id of the typeThing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeThingDelete(typeThingId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).typeThingDelete(typeThingId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a specific typeThing
         * @summary TypeThingGet will retrieve in backend all information about a specific typeThingId
         * @param {number} typeThingId Id of the typeThing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeThingGet(typeThingId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TypeThing>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).typeThingGet(typeThingId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the types in an array
         * @summary TypeThingList returns a list of types
         * @param {string} [keywords] text keywords to filter the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {number} [externalId] id of the external id to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeThingList(keywords?: string, createdBy?: number, externalId?: number, inactivated?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<TypeThingList>>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).typeThingList(keywords, createdBy, externalId, inactivated, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the information related to a typeThing
         * @summary TypeThingUpdate allows to modify information about a specific typeThingId
         * @param {number} typeThingId Id of the typeThing
         * @param {number} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [comment] 
         * @param {number} [externalId] 
         * @param {string} [tableName] 
         * @param {string} [geometryType] 
         * @param {boolean} [inactivated] 
         * @param {Date} [inactivatedTime] 
         * @param {number} [inactivatedBy] 
         * @param {string} [inactivatedReason] 
         * @param {number} [managedBy] 
         * @param {Date} [createdAt] 
         * @param {number} [createdBy] 
         * @param {Date} [lastModifiedAt] 
         * @param {number} [lastModifiedBy] 
         * @param {boolean} [deleted] 
         * @param {Date} [deletedAt] 
         * @param {number} [deletedBy] 
         * @param {any} [moreDataSchema] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeThingUpdateForm(typeThingId: number, id?: number, name?: string, description?: string, comment?: string, externalId?: number, tableName?: string, geometryType?: string, inactivated?: boolean, inactivatedTime?: Date, inactivatedBy?: number, inactivatedReason?: string, managedBy?: number, createdAt?: Date, createdBy?: number, lastModifiedAt?: Date, lastModifiedBy?: number, deleted?: boolean, deletedAt?: Date, deletedBy?: number, moreDataSchema?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TypeThing>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).typeThingUpdateForm(typeThingId, id, name, description, comment, externalId, tableName, geometryType, inactivated, inactivatedTime, inactivatedBy, inactivatedReason, managedBy, createdAt, createdBy, lastModifiedAt, lastModifiedBy, deleted, deletedAt, deletedBy, moreDataSchema, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the status of a thing
         * @summary Update allows to modify information about a specific thingId
         * @param {string} thingId Id of the thing
         * @param {string} [id] 
         * @param {number} [typeId] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [comment] 
         * @param {number} [externalId] 
         * @param {string} [externalRef] 
         * @param {string} [buildAt] 
         * @param {ThingStatus} [status] 
         * @param {string} [containedBy] 
         * @param {number} [containedByOld] 
         * @param {boolean} [inactivated] 
         * @param {Date} [inactivatedTime] 
         * @param {number} [inactivatedBy] 
         * @param {string} [inactivatedReason] 
         * @param {boolean} [validated] 
         * @param {Date} [validatedTime] 
         * @param {number} [validatedBy] 
         * @param {number} [managedBy] 
         * @param {Date} [createdAt] 
         * @param {number} [createdBy] 
         * @param {Date} [lastModifiedAt] 
         * @param {number} [lastModifiedBy] 
         * @param {boolean} [deleted] 
         * @param {Date} [deletedAt] 
         * @param {number} [deletedBy] 
         * @param {any} [moreData] 
         * @param {number} [posX] 
         * @param {number} [posY] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateForm(thingId: string, id?: string, typeId?: number, name?: string, description?: string, comment?: string, externalId?: number, externalRef?: string, buildAt?: string, status?: ThingStatus, containedBy?: string, containedByOld?: number, inactivated?: boolean, inactivatedTime?: Date, inactivatedBy?: number, inactivatedReason?: string, validated?: boolean, validatedTime?: Date, validatedBy?: number, managedBy?: number, createdAt?: Date, createdBy?: number, lastModifiedAt?: Date, lastModifiedBy?: number, deleted?: boolean, deletedAt?: Date, deletedBy?: number, moreData?: any, posX?: number, posY?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Thing>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).updateForm(thingId, id, typeId, name, description, comment, externalId, externalRef, buildAt, status, containedBy, containedByOld, inactivated, inactivatedTime, inactivatedBy, inactivatedReason, validated, validatedTime, validatedBy, managedBy, createdAt, createdBy, lastModifiedAt, lastModifiedBy, deleted, deletedAt, deletedBy, moreData, posX, posY, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * delete a thing
         * @summary Delete allows to delete a specific thingId
         * @param {string} thingId Id of the thing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(thingId: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return DefaultApiFp(configuration)._delete(thingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the number of things found after filtering with passed criterias
         * @summary Count returns the number of thing based on search criterias
         * @param {string} [keywords] text keywords to filter the things to return
         * @param {number} [type] TypeThing id to filter by the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {boolean} [validated] validation flag to filter the things to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async count(keywords?: string, type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<number>> {
            return DefaultApiFp(configuration).count(keywords, type, createdBy, inactivated, validated, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new thing
         * @summary Create will create a new thing
         * @param {Thing} body Thing to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(body: Thing, options?: AxiosRequestConfig): Promise<AxiosResponse<Thing>> {
            return DefaultApiFp(configuration).create(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific thing
         * @summary Get will retrieve in backend all information about a specific thingId
         * @param {string} thingId Id of the thing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(thingId: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Thing>> {
            return DefaultApiFp(configuration).get(thingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the thing in an array
         * @summary List returns a list of thing
         * @param {number} [type] TypeThing id to filter by the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {boolean} [validated] validation flag to filter the things to return
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<ThingList>>> {
            return DefaultApiFp(configuration).list(type, createdBy, inactivated, validated, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the things in an array
         * @summary ListByExternalId returns a list of thing filtered by externalId
         * @param {number} externalId externalId of the things needed
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listByExternalId(externalId: number, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<ThingList>>> {
            return DefaultApiFp(configuration).listByExternalId(externalId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the thing in an array
         * @summary Search returns a list of thing based on search criterias
         * @param {string} [keywords] text keywords to filter the things to return
         * @param {number} [type] TypeThing id to filter by the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {boolean} [validated] validation flag to filter the things to return
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(keywords?: string, type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<ThingList>>> {
            return DefaultApiFp(configuration).search(keywords, type, createdBy, inactivated, validated, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the number of TypeThings found after filtering with passed criterias
         * @summary Count returns the number of TypeThing based on search criterias
         * @param {string} [keywords] text keywords to filter the TypeThing count
         * @param {number} [createdBy] id of the creator to filter the TypeThing count
         * @param {boolean} [inactivated] inactivated flag to filter the TypeThing count to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeThingCount(keywords?: string, createdBy?: number, inactivated?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<number>> {
            return DefaultApiFp(configuration).typeThingCount(keywords, createdBy, inactivated, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new group
         * @summary TypeThingCreate will create a new group
         * @param {TypeThing} body TypeThing to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeThingCreate(body: TypeThing, options?: AxiosRequestConfig): Promise<AxiosResponse<TypeThing>> {
            return DefaultApiFp(configuration).typeThingCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a typeThing
         * @summary TypeThingDelete allows to delete a specific typeThingId
         * @param {number} typeThingId Id of the typeThing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeThingDelete(typeThingId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return DefaultApiFp(configuration).typeThingDelete(typeThingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific typeThing
         * @summary TypeThingGet will retrieve in backend all information about a specific typeThingId
         * @param {number} typeThingId Id of the typeThing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeThingGet(typeThingId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<TypeThing>> {
            return DefaultApiFp(configuration).typeThingGet(typeThingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the types in an array
         * @summary TypeThingList returns a list of types
         * @param {string} [keywords] text keywords to filter the things to return
         * @param {number} [createdBy] id of the creator to filter by the things to return
         * @param {number} [externalId] id of the external id to filter by the things to return
         * @param {boolean} [inactivated] inactivated flag to filter the things to return
         * @param {number} [limit] maximum number of results to return
         * @param {number} [offset] offset rows to skip before returning rows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeThingList(keywords?: string, createdBy?: number, externalId?: number, inactivated?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<TypeThingList>>> {
            return DefaultApiFp(configuration).typeThingList(keywords, createdBy, externalId, inactivated, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the information related to a typeThing
         * @summary TypeThingUpdate allows to modify information about a specific typeThingId
         * @param {number} typeThingId Id of the typeThing
         * @param {number} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [comment] 
         * @param {number} [externalId] 
         * @param {string} [tableName] 
         * @param {string} [geometryType] 
         * @param {boolean} [inactivated] 
         * @param {Date} [inactivatedTime] 
         * @param {number} [inactivatedBy] 
         * @param {string} [inactivatedReason] 
         * @param {number} [managedBy] 
         * @param {Date} [createdAt] 
         * @param {number} [createdBy] 
         * @param {Date} [lastModifiedAt] 
         * @param {number} [lastModifiedBy] 
         * @param {boolean} [deleted] 
         * @param {Date} [deletedAt] 
         * @param {number} [deletedBy] 
         * @param {any} [moreDataSchema] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeThingUpdateForm(typeThingId: number, id?: number, name?: string, description?: string, comment?: string, externalId?: number, tableName?: string, geometryType?: string, inactivated?: boolean, inactivatedTime?: Date, inactivatedBy?: number, inactivatedReason?: string, managedBy?: number, createdAt?: Date, createdBy?: number, lastModifiedAt?: Date, lastModifiedBy?: number, deleted?: boolean, deletedAt?: Date, deletedBy?: number, moreDataSchema?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<TypeThing>> {
            return DefaultApiFp(configuration).typeThingUpdateForm(typeThingId, id, name, description, comment, externalId, tableName, geometryType, inactivated, inactivatedTime, inactivatedBy, inactivatedReason, managedBy, createdAt, createdBy, lastModifiedAt, lastModifiedBy, deleted, deletedAt, deletedBy, moreDataSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the status of a thing
         * @summary Update allows to modify information about a specific thingId
         * @param {string} thingId Id of the thing
         * @param {string} [id] 
         * @param {number} [typeId] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [comment] 
         * @param {number} [externalId] 
         * @param {string} [externalRef] 
         * @param {string} [buildAt] 
         * @param {ThingStatus} [status] 
         * @param {string} [containedBy] 
         * @param {number} [containedByOld] 
         * @param {boolean} [inactivated] 
         * @param {Date} [inactivatedTime] 
         * @param {number} [inactivatedBy] 
         * @param {string} [inactivatedReason] 
         * @param {boolean} [validated] 
         * @param {Date} [validatedTime] 
         * @param {number} [validatedBy] 
         * @param {number} [managedBy] 
         * @param {Date} [createdAt] 
         * @param {number} [createdBy] 
         * @param {Date} [lastModifiedAt] 
         * @param {number} [lastModifiedBy] 
         * @param {boolean} [deleted] 
         * @param {Date} [deletedAt] 
         * @param {number} [deletedBy] 
         * @param {any} [moreData] 
         * @param {number} [posX] 
         * @param {number} [posY] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateForm(thingId: string, id?: string, typeId?: number, name?: string, description?: string, comment?: string, externalId?: number, externalRef?: string, buildAt?: string, status?: ThingStatus, containedBy?: string, containedByOld?: number, inactivated?: boolean, inactivatedTime?: Date, inactivatedBy?: number, inactivatedReason?: string, validated?: boolean, validatedTime?: Date, validatedBy?: number, managedBy?: number, createdAt?: Date, createdBy?: number, lastModifiedAt?: Date, lastModifiedBy?: number, deleted?: boolean, deletedAt?: Date, deletedBy?: number, moreData?: any, posX?: number, posY?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Thing>> {
            return DefaultApiFp(configuration).updateForm(thingId, id, typeId, name, description, comment, externalId, externalRef, buildAt, status, containedBy, containedByOld, inactivated, inactivatedTime, inactivatedBy, inactivatedReason, validated, validatedTime, validatedBy, managedBy, createdAt, createdBy, lastModifiedAt, lastModifiedBy, deleted, deletedAt, deletedBy, moreData, posX, posY, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * delete a thing
     * @summary Delete allows to delete a specific thingId
     * @param {string} thingId Id of the thing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async _delete(thingId: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return DefaultApiFp(this.configuration)._delete(thingId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the number of things found after filtering with passed criterias
     * @summary Count returns the number of thing based on search criterias
     * @param {string} [keywords] text keywords to filter the things to return
     * @param {number} [type] TypeThing id to filter by the things to return
     * @param {number} [createdBy] id of the creator to filter by the things to return
     * @param {boolean} [inactivated] inactivated flag to filter the things to return
     * @param {boolean} [validated] validation flag to filter the things to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async count(keywords?: string, type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<number>> {
        return DefaultApiFp(this.configuration).count(keywords, type, createdBy, inactivated, validated, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new thing
     * @summary Create will create a new thing
     * @param {Thing} body Thing to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async create(body: Thing, options?: AxiosRequestConfig) : Promise<AxiosResponse<Thing>> {
        return DefaultApiFp(this.configuration).create(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a specific thing
     * @summary Get will retrieve in backend all information about a specific thingId
     * @param {string} thingId Id of the thing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async get(thingId: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Thing>> {
        return DefaultApiFp(this.configuration).get(thingId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the thing in an array
     * @summary List returns a list of thing
     * @param {number} [type] TypeThing id to filter by the things to return
     * @param {number} [createdBy] id of the creator to filter by the things to return
     * @param {boolean} [inactivated] inactivated flag to filter the things to return
     * @param {boolean} [validated] validation flag to filter the things to return
     * @param {number} [limit] maximum number of results to return
     * @param {number} [offset] offset rows to skip before returning rows
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async list(type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<ThingList>>> {
        return DefaultApiFp(this.configuration).list(type, createdBy, inactivated, validated, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the things in an array
     * @summary ListByExternalId returns a list of thing filtered by externalId
     * @param {number} externalId externalId of the things needed
     * @param {number} [limit] maximum number of results to return
     * @param {number} [offset] offset rows to skip before returning rows
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async listByExternalId(externalId: number, limit?: number, offset?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<ThingList>>> {
        return DefaultApiFp(this.configuration).listByExternalId(externalId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the thing in an array
     * @summary Search returns a list of thing based on search criterias
     * @param {string} [keywords] text keywords to filter the things to return
     * @param {number} [type] TypeThing id to filter by the things to return
     * @param {number} [createdBy] id of the creator to filter by the things to return
     * @param {boolean} [inactivated] inactivated flag to filter the things to return
     * @param {boolean} [validated] validation flag to filter the things to return
     * @param {number} [limit] maximum number of results to return
     * @param {number} [offset] offset rows to skip before returning rows
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async search(keywords?: string, type?: number, createdBy?: number, inactivated?: boolean, validated?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<ThingList>>> {
        return DefaultApiFp(this.configuration).search(keywords, type, createdBy, inactivated, validated, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the number of TypeThings found after filtering with passed criterias
     * @summary Count returns the number of TypeThing based on search criterias
     * @param {string} [keywords] text keywords to filter the TypeThing count
     * @param {number} [createdBy] id of the creator to filter the TypeThing count
     * @param {boolean} [inactivated] inactivated flag to filter the TypeThing count to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async typeThingCount(keywords?: string, createdBy?: number, inactivated?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<number>> {
        return DefaultApiFp(this.configuration).typeThingCount(keywords, createdBy, inactivated, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new group
     * @summary TypeThingCreate will create a new group
     * @param {TypeThing} body TypeThing to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async typeThingCreate(body: TypeThing, options?: AxiosRequestConfig) : Promise<AxiosResponse<TypeThing>> {
        return DefaultApiFp(this.configuration).typeThingCreate(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a typeThing
     * @summary TypeThingDelete allows to delete a specific typeThingId
     * @param {number} typeThingId Id of the typeThing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async typeThingDelete(typeThingId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return DefaultApiFp(this.configuration).typeThingDelete(typeThingId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a specific typeThing
     * @summary TypeThingGet will retrieve in backend all information about a specific typeThingId
     * @param {number} typeThingId Id of the typeThing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async typeThingGet(typeThingId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<TypeThing>> {
        return DefaultApiFp(this.configuration).typeThingGet(typeThingId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the types in an array
     * @summary TypeThingList returns a list of types
     * @param {string} [keywords] text keywords to filter the things to return
     * @param {number} [createdBy] id of the creator to filter by the things to return
     * @param {number} [externalId] id of the external id to filter by the things to return
     * @param {boolean} [inactivated] inactivated flag to filter the things to return
     * @param {number} [limit] maximum number of results to return
     * @param {number} [offset] offset rows to skip before returning rows
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async typeThingList(keywords?: string, createdBy?: number, externalId?: number, inactivated?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<TypeThingList>>> {
        return DefaultApiFp(this.configuration).typeThingList(keywords, createdBy, externalId, inactivated, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the information related to a typeThing
     * @summary TypeThingUpdate allows to modify information about a specific typeThingId
     * @param {number} typeThingId Id of the typeThing
     * @param {number} [id] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [comment] 
     * @param {number} [externalId] 
     * @param {string} [tableName] 
     * @param {string} [geometryType] 
     * @param {boolean} [inactivated] 
     * @param {Date} [inactivatedTime] 
     * @param {number} [inactivatedBy] 
     * @param {string} [inactivatedReason] 
     * @param {number} [managedBy] 
     * @param {Date} [createdAt] 
     * @param {number} [createdBy] 
     * @param {Date} [lastModifiedAt] 
     * @param {number} [lastModifiedBy] 
     * @param {boolean} [deleted] 
     * @param {Date} [deletedAt] 
     * @param {number} [deletedBy] 
     * @param {any} [moreDataSchema] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async typeThingUpdateForm(typeThingId: number, id?: number, name?: string, description?: string, comment?: string, externalId?: number, tableName?: string, geometryType?: string, inactivated?: boolean, inactivatedTime?: Date, inactivatedBy?: number, inactivatedReason?: string, managedBy?: number, createdAt?: Date, createdBy?: number, lastModifiedAt?: Date, lastModifiedBy?: number, deleted?: boolean, deletedAt?: Date, deletedBy?: number, moreDataSchema?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<TypeThing>> {
        return DefaultApiFp(this.configuration).typeThingUpdateForm(typeThingId, id, name, description, comment, externalId, tableName, geometryType, inactivated, inactivatedTime, inactivatedBy, inactivatedReason, managedBy, createdAt, createdBy, lastModifiedAt, lastModifiedBy, deleted, deletedAt, deletedBy, moreDataSchema, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the status of a thing
     * @summary Update allows to modify information about a specific thingId
     * @param {string} thingId Id of the thing
     * @param {string} [id] 
     * @param {number} [typeId] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [comment] 
     * @param {number} [externalId] 
     * @param {string} [externalRef] 
     * @param {string} [buildAt] 
     * @param {ThingStatus} [status] 
     * @param {string} [containedBy] 
     * @param {number} [containedByOld] 
     * @param {boolean} [inactivated] 
     * @param {Date} [inactivatedTime] 
     * @param {number} [inactivatedBy] 
     * @param {string} [inactivatedReason] 
     * @param {boolean} [validated] 
     * @param {Date} [validatedTime] 
     * @param {number} [validatedBy] 
     * @param {number} [managedBy] 
     * @param {Date} [createdAt] 
     * @param {number} [createdBy] 
     * @param {Date} [lastModifiedAt] 
     * @param {number} [lastModifiedBy] 
     * @param {boolean} [deleted] 
     * @param {Date} [deletedAt] 
     * @param {number} [deletedBy] 
     * @param {any} [moreData] 
     * @param {number} [posX] 
     * @param {number} [posY] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async updateForm(thingId: string, id?: string, typeId?: number, name?: string, description?: string, comment?: string, externalId?: number, externalRef?: string, buildAt?: string, status?: ThingStatus, containedBy?: string, containedByOld?: number, inactivated?: boolean, inactivatedTime?: Date, inactivatedBy?: number, inactivatedReason?: string, validated?: boolean, validatedTime?: Date, validatedBy?: number, managedBy?: number, createdAt?: Date, createdBy?: number, lastModifiedAt?: Date, lastModifiedBy?: number, deleted?: boolean, deletedAt?: Date, deletedBy?: number, moreData?: any, posX?: number, posY?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Thing>> {
        return DefaultApiFp(this.configuration).updateForm(thingId, id, typeId, name, description, comment, externalId, externalRef, buildAt, status, containedBy, containedByOld, inactivated, inactivatedTime, inactivatedBy, inactivatedReason, validated, validatedTime, validatedBy, managedBy, createdAt, createdBy, lastModifiedAt, lastModifiedBy, deleted, deletedAt, deletedBy, moreData, posX, posY, options).then((request) => request(this.axios, this.basePath));
    }
}
